<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cosmic Clicker</title>
    <style>
      :root {
        --slate-900: #0f172a;
        --slate-800: #1e293b;
        --slate-700: #334155;
        --slate-400: #94a3b8;
        --gray-100: #f3f4f6;
        --cyan-300: #67e8f9;
        --cyan-400: #22d3ee;
        --yellow-200: #fef08a;
        --yellow-300: #fde047;
        --yellow-400: #facc15;
        --yellow-500: #eab308;
        --purple-300: #d8b4fe;
        --purple-400: #c084fc;
        --red-400: #f87171;
        --red-500: #ef4444;
        --red-600: #dc2626;
        --red-800: #991b1b;
        --green-600: #16a34a;

        --font-sans: 'Roboto', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
        --font-display: 'Orbitron', var(--font-sans);
      }

      *, *::before, *::after {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: var(--font-sans);
        background-color: var(--slate-900);
        color: var(--gray-100);
        line-height: 1.5;
      }

      #root {
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }
      
      .font-orbitron {
        font-family: var(--font-display);
      }

      /* Animations */
      @keyframes spin-slow {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
      }
      @keyframes spin-slow-reverse {
          from { transform: rotate(360deg); }
          to { transform: rotate(0deg); }
      }
      @keyframes float-up {
        0% {
          opacity: 1;
          transform: translate(-50%, -50%) translateY(0);
        }
        100% {
          opacity: 0;
          transform: translate(-50%, -100%) translateY(-50px);
        }
      }
      @keyframes orb-pulse {
          0%, 100% {
              transform: translate(-50%, -50%) scale(1);
              opacity: 0.8;
          }
          50% {
              transform: translate(-50%, -50%) scale(1.1);
              opacity: 1;
          }
      }
      @keyframes pulse {
        0%, 100% {
          opacity: 1;
        }
        50% {
          opacity: .5;
        }
      }
      @keyframes asteroid-float {
        0% { transform: translate(-50%, -50%) rotate(0deg) translateX(5px) rotate(0deg); }
        100% { transform: translate(-50%, -50%) rotate(360deg) translateX(5px) rotate(-360deg); }
      }
      @keyframes collect-effect {
        from {
          transform: translate(-50%, -50%) scale(0);
          opacity: 1;
        }
        to {
          transform: translate(-50%, -50%) scale(1);
          opacity: 0;
        }
      }
      
      /* New Supernova Animations */
      @keyframes supernova-fade-in-out {
        0% { opacity: 0; }
        10% { opacity: 1; }
        90% { opacity: 1; }
        100% { opacity: 0; }
      }
      @keyframes supernova-core-collapse-explode {
        0% { transform: scale(300); opacity: 0.5; }
        33% { transform: scale(0.1); opacity: 1; } /* Collapse phase */
        37% { transform: scale(0.1); opacity: 1; } /* Hold */
        100% { transform: scale(500); opacity: 0; } /* Explode phase */
      }
      @keyframes supernova-shockwave-ring {
        0% { transform: scale(0); opacity: 1; }
        100% { transform: scale(3); opacity: 0; }
      }

      /* Prestige Sequence Animations */
      @keyframes shake-subtle {
        0%, 100% { transform: translateX(0); }
        25% { transform: translateX(-5px); }
        50% { transform: translateX(5px); }
        75% { transform: translateX(-5px); }
      }
      @keyframes ui-slide-out-top {
        to { transform: translateY(-150%); opacity: 0; }
      }
      @keyframes ui-slide-out-right {
        to { transform: translateX(150%); opacity: 0; }
      }
       @keyframes ui-slide-in-top {
        from { transform: translateY(-150%); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
      }
      @keyframes ui-slide-in-right {
        from { transform: translateX(150%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
      }
      @keyframes star-collapse-to-center {
        0% { transform: scale(1); }
        100% { transform: scale(0); }
      }
      @keyframes modal-fade-in {
        from { opacity: 0; transform: scale(0.95); }
        to { opacity: 1; transform: scale(1); }
      }


      .animate-spin-slow { animation: spin-slow 20s linear infinite; }
      .animate-spin-slow-reverse { animation: spin-slow-reverse 30s linear infinite; }
      .animate-float-up { animation: float-up 2s ease-out forwards; }
      .animate-orb-pulse { animation: orb-pulse 2.5s ease-in-out infinite; }
      .animate-pulse { animation: pulse 3s cubic-bezier(0.4,0,0.6,1) infinite; }
      .animate-asteroid-float { animation: asteroid-float 10s linear infinite; }
      .animate-collect-effect { animation: collect-effect 0.5s ease-out forwards; }
      
      button {
        font-family: inherit;
        font-size: 100%;
        line-height: 1.15;
        margin: 0;
        padding: 0;
        background-color: transparent;
        border: none;
        color: inherit;
        cursor: pointer;
      }

      button:focus {
        outline: 1px dotted;
        outline: 5px auto -webkit-focus-ring-color;
      }

      button:disabled {
        cursor: not-allowed;
      }

    </style>
    <!-- Load React and ReactDOM from CDN -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <!-- Load Babel for JSX transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script type="importmap">
{
  "imports": {
    "react/": "https://aistudiocdn.com/react@^19.1.1/",
    "react": "https://aistudiocdn.com/react@^19.1.1",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.1.1/"
  }
}
</script>
</head>
  <body class="bg-slate-900 text-gray-100">
    <div id="root"></div>
    <script type="text/babel" data-presets="react,typescript">
const { useState, useEffect, useCallback, useMemo, useRef, StrictMode } = React;

// === FROM types.ts ===
const Currency = {
  Stardust: 'Stardust',
  NebulaGas: 'Nebula Gas',
  Antimatter: 'Antimatter',
};

const UpgradeType = {
  Click: 'Click',
  Passive: 'Passive',
  Utility: 'Utility',
  Prestige: 'Prestige',
};


// === FROM utils/format.ts ===
const formatNumber = (num) => {
    if (typeof num !== 'number' || isNaN(num)) {
        num = 0;
    }
    if (num < 1000) {
        return num.toFixed(1).replace(/\.0$/, '');
    }
    const si = [
        { value: 1, symbol: "" },
        { value: 1E3, symbol: "K" },
        { value: 1E6, symbol: "M" },
        { value: 1E9, symbol: "B" },
        { value: 1E12, symbol: "T" },
        { value: 1E15, symbol: "P" },
        { value: 1E18, symbol: "E" }
    ];
    const rx = /\.0+$|(\.[0-9]*[1-9])0+$/;
    let i;
    for (i = si.length - 1; i > 0; i--) {
        if (num >= si[i].value) {
            break;
        }
    }
    return (num / si[i].value).toFixed(2).replace(rx, "$1") + si[i].symbol;
};

const formatDuration = (seconds) => {
    if (seconds < 60) return `${Math.floor(seconds)} secondes`;
    if (seconds < 3600) return `${Math.floor(seconds / 60)} minutes`;
    if (seconds < 86400) return `${Math.floor(seconds / 3600)} heures`;
    return `${Math.floor(seconds / 86400)} jours`;
};

// === FROM components/icons.tsx ===
const StardustIcon = () => (
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-full h-full">
    <path fillRule="evenodd" d="M10.788 3.21c.448-1.077 1.976-1.077 2.424 0l2.082 5.007 5.404.433c1.164.093 1.636 1.545.749 2.305l-4.117 3.527 1.257 5.273c.271 1.136-.964 2.033-1.96 1.425L12 18.354 7.373 21.18c-.996.608-2.231-.29-1.96-1.425l1.257-5.273-4.117-3.527c-.887-.76-.415-2.212.749-2.305l5.404-.433 2.082-5.007z" clipRule="evenodd" />
  </svg>
);

const NebulaGasIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-full h-full">
        <path d="M6.061 3.144C7.035 1.833 8.835 1.48 10.29 2.213L11 2.667l.71-.453c1.454-.733 3.255-.38 4.228.931s.913 3.233-.043 4.54L15.41 8.5l.485.647c1.157 1.543 1.293 3.695.38 5.433s-2.73 2.613-4.48 2.373l-.855-.117-.855.117c-1.75.24-3.57.067-4.48-2.373s-.777-3.89.38-5.433L6.59 8.5l-.485-.809c-.957-1.307-.753-3.233.228-4.54zM4.5 15.75c-.828 0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h15c.828 0 1.5-.672 1.5-1.5s-.672-1.5-1.5-1.5h-15z" />
    </svg>
);

const AntimatterIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-full h-full">
        <path d="M12 2a10 10 0 100 20 10 10 0 000-20zm0 4a6 6 0 100 12 6 6 0 000-12zm0 2a4 4 0 110 8 4 4 0 010-8zm0 2a2 2 0 100 4 2 2 0 000-4z" />
        <path d="M12 2C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2zm0 18a8 8 0 110-16 8 8 0 010 16z" transform="rotate(45 12 12)"/>
    </svg>
);

const AsteroidIcon = () => (
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-full h-full">
    <path fillRule="evenodd" d="M12.96 3.63a.75.75 0 01.103.023l7.5 3.001a.75.75 0 010 1.393l-7.5 3a.75.75 0 01-.866-.104l-3-3.75a.75.75 0 01.047-.98l3.75-3.75a.75.75 0 01.926-.033zM5.48 8.924a.75.75 0 01.103-.023l7.5 3.001a.75.75 0 010 1.393l-7.5 3a.75.75 0 01-.866-.104l-3-3.75a.75.75 0 01.047-.98l3.75-3.75a.75.75 0 01.926-.033z" clipRule="evenodd" />
    <path d="M11.03 13.5a.75.75 0 01.11-.01l7.5 3.001a.75.75 0 010 1.393l-7.5 3a.75.75 0 01-.866-.104l-3-3.75a.75.75 0 01.047-.98l3.75-3.75a.75.75 0 01.926-.033z" />
  </svg>
);

const DroneIcon = () => (
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-full h-full">
    <path d="M12 2.25a.75.75 0 01.75.75v2.5a.75.75 0 01-1.5 0V3a.75.75 0 01.75-.75zM7.5 12a4.5 4.5 0 119 0 4.5 4.5 0 01-9 0zM18.894 6.196a.75.75 0 00-1.06-1.06l-1.768 1.768a.75.75 0 101.06 1.06l1.768-1.768zM6.196 18.894a.75.75 0 001.06 1.06l1.768-1.768a.75.75 0 10-1.06-1.06l-1.768 1.768zM18.894 18.894a.75.75 0 001.06-1.06l-1.768-1.768a.75.75 0 10-1.06 1.06l1.768 1.768zM6.196 6.196a.75.75 0 00-1.06 1.06l1.768 1.768a.75.75 0 101.06-1.06L6.196 6.196zM12 21.75a.75.75 0 01-.75-.75v-2.5a.75.75 0 011.5 0V21a.75.75 0 01-.75.75zM3 12.75a.75.75 0 01-.75-.75H.75a.75.75 0 010-1.5h1.5a.75.75 0 01.75.75v0a.75.75 0 01-.75.75zM21 12a.75.75 0 00.75.75h1.5a.75.75 0 000-1.5h-1.5a.75.75 0 00-.75.75z" />
  </svg>
);


const StatsIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-full h-full">
      <path strokeLinecap="round" strokeLinejoin="round" d="M3 13.125C3 12.504 3.504 12 4.125 12h2.25c.621 0 1.125.504 1.125 1.125v6.75C7.5 20.496 6.996 21 6.375 21h-2.25A1.125 1.125 0 0 1 3 19.875v-6.75ZM9.75 8.625c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125v11.25c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 0 1-1.125-1.125V8.625ZM16.5 4.125c0-.621.504-1.125 1.125-1.125h2.25C20.496 3 21 3.504 21 4.125v15.75c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 0 1-1.125-1.125V4.125Z" />
    </svg>
);

// === FROM hooks/useGameLoop.ts ===
const useGameLoop = (callback, interval) => {
  const savedCallback = useRef(callback);

  useEffect(() => {
    savedCallback.current = callback;
  }, [callback]);

  useEffect(() => {
    const tick = () => {
      savedCallback.current();
    };
    if (interval !== null) {
      const id = setInterval(tick, interval);
      return () => clearInterval(id);
    }
  }, [interval]);
};

// === FROM components/UpgradeButton.tsx ===
const getCurrencyIcon = (currency) => {
  switch (currency) {
    case Currency.Stardust:
      return <StardustIcon />;
    case Currency.NebulaGas:
      return <NebulaGasIcon />;
    case Currency.Antimatter:
      return <AntimatterIcon />;
  }
};

const getCurrencyColor = (currency) => {
  switch (currency) {
    case Currency.Stardust:
      return '#fde047';
    case Currency.NebulaGas:
      return '#d8b4fe';
    case Currency.Antimatter:
      return '#f87171';
  }
}

const UpgradeButton = ({ upgrade, onPurchase, canAfford }) => {
  const isMaxLevel = upgrade.maxLevel && upgrade.level >= upgrade.maxLevel;

  return (
    <button
      onClick={() => onPurchase(upgrade.id)}
      disabled={!canAfford || isMaxLevel}
      className="upgrade-button"
    >
      <style>{`
        .upgrade-button {
          width: 100%;
          text-align: left;
          padding: 0.75rem;
          background-color: rgba(15, 23, 42, 0.5);
          border-radius: 0.5rem;
          border: 1px solid #334155;
          transition: all 200ms;
        }
        .upgrade-button:hover:not(:disabled) {
          background-color: rgba(51, 65, 85, 0.5);
          border-color: #22d3ee;
        }
        .upgrade-button:disabled {
          opacity: 0.5;
          cursor: not-allowed;
        }
      `}</style>
      <div style={{pointerEvents: 'none'}}>
        <div style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center'}}>
          <h4 className="font-orbitron" style={{fontWeight: 'bold'}}>{upgrade.name}</h4>
          <span style={{
            fontSize: '0.875rem',
            fontWeight: 600,
            padding: '0.25rem 0.5rem',
            borderRadius: '0.25rem',
            backgroundColor: isMaxLevel ? '#16a34a' : '#334155',
            color: isMaxLevel ? 'white' : 'inherit'
          }}>
              {isMaxLevel ? 'MAX' : `Lvl ${upgrade.level}`}
          </span>
        </div>
        <p style={{fontSize: '0.75rem', color: '#94a3b8', marginTop: '0.25rem'}}>{upgrade.description}</p>
        <div style={{display: 'flex', alignItems: 'center', gap: '0.5rem', marginTop: '0.5rem', fontWeight: 600, color: getCurrencyColor(upgrade.currency)}}>
          {!isMaxLevel && (
              <>
                  <div style={{width: '1rem', height: '1rem'}}>{getCurrencyIcon(upgrade.currency)}</div>
                  <span>{formatNumber(upgrade.cost)}</span>
              </>
          )}
        </div>
      </div>
    </button>
  );
};


// === FROM components/UpgradesPanel.tsx ===
const TabButton = ({ tab, activeTab, onClick, icon }) => (
    <button
      onClick={() => onClick(tab)}
      className="tab-button"
      data-active={activeTab === tab}
      aria-pressed={activeTab === tab}
    >
      <style>{`
        .tab-button {
          display: flex;
          flex: 1 1 0%;
          align-items: center;
          justify-content: center;
          gap: 0.5rem;
          padding: 0.75rem;
          font-size: 0.875rem;
          font-weight: bold;
          border-bottom: 2px solid;
          transition: color 200ms, border-color 200ms;
          border-color: transparent;
          color: #94a3b8;
        }
        .tab-button:hover {
          color: #67e8f9;
        }
        .tab-button[data-active="true"] {
          border-color: #22d3ee;
          color: #22d3ee;
        }
      `}</style>
        <div style={{width: '1.25rem', height: '1.25rem', pointerEvents: 'none'}}>{icon}</div>
        <span style={{pointerEvents: 'none'}}>{tab}</span>
    </button>
);

const StatDisplay = ({ label, value }) => (
    <div style={{backgroundColor: 'rgba(15, 23, 42, 0.5)', padding: '0.75rem', borderRadius: '0.5rem', display: 'flex', justifyContent: 'space-between', alignItems: 'baseline'}}>
        <dt style={{fontSize: '0.875rem', color: '#94a3b8'}}>{label}</dt>
        <dd className="font-orbitron" style={{fontWeight: 'bold', color: '#67e8f9'}}>{value}</dd>
    </div>
);

const StatsPanel = ({ stardustHistory, nebulaHistory, stats, onReset }) => {
    const stardustPoints = stardustHistory.map(d => d.totalStardust);
    const stardustMaxY = Math.max(...stardustPoints, 1);
    const stardustMinY = stardustHistory.length > 0 ? Math.min(...stardustPoints) : 0;
    const stardustRange = stardustMaxY - stardustMinY;
    
    const getStardustPathData = () => {
        if (stardustRange <= 0) return 'M 0,50 L 300,50';
        return stardustPoints.map((p, i) => {
            const x = (i / (stardustPoints.length - 1)) * 300;
            const y = 100 - ((p - stardustMinY) / stardustRange) * 100;
            return `${x},${y}`;
        }).join(' L ');
    };
    const stardustPathData = stardustHistory.length < 2 ? 'M 0,50 L 300,50' : getStardustPathData();

    const nebulaPoints = nebulaHistory.map(d => d.totalNebulaGas);
    const nebulaMaxY = Math.max(...nebulaPoints, 1);
    const nebulaMinY = nebulaHistory.length > 0 ? Math.min(...nebulaPoints) : 0;
    const nebulaRange = nebulaMaxY - nebulaMinY;

    const getNebulaPathData = () => {
        if (nebulaRange <= 0) return 'M 0,50 L 300,50';
        return nebulaPoints.map((p, i) => {
            const x = (i / (nebulaPoints.length - 1)) * 300;
            const y = 100 - ((p - nebulaMinY) / nebulaRange) * 100;
            return `${x},${y}`;
        }).join(' L ');
    };
    const nebulaPathData = nebulaHistory.length < 2 ? 'M 0,50 L 300,50' : getNebulaPathData();


    return (
        <div style={{padding: '1rem', display: 'flex', flexDirection: 'column', gap: '1rem'}}>
            <div>
                <h3 className="font-orbitron" style={{fontSize: '1.125rem', marginBottom: '0.5rem', textAlign: 'center', color: '#67e8f9'}}>Stardust Total</h3>
                {stardustHistory.length < 2 ? (
                    <div style={{textAlign: 'center', padding: '1rem', color: '#94a3b8'}}>Collecte des données...</div>
                ) : (
                    <div style={{position: 'relative', height: '6rem'}}>
                        <svg viewBox={`0 0 300 100`} style={{width: '100%', height: '100%'}} preserveAspectRatio="none">
                            <defs>
                                <linearGradient id="areaGradient" x1="0" x2="0" y1="0" y2="1">
                                    <stop offset="0%" stopColor="#06b6d4" stopOpacity="0.4"/>
                                    <stop offset="100%" stopColor="#06b6d4" stopOpacity="0"/>
                                </linearGradient>
                            </defs>
                            <path d={'M ' + stardustPathData} fill="none" stroke="#06b6d4" strokeWidth="2" />
                            <path d={`M ${stardustPathData.split(' ')[0]} L ${stardustPathData} L 300,100 L 0,100 Z`} fill="url(#areaGradient)" />
                        </svg>
                        <div style={{position: 'absolute', top: 0, left: 0, fontSize: '0.75rem', color: '#94a3b8'}}>{formatNumber(stardustMaxY)}</div>
                        <div style={{position: 'absolute', bottom: 0, left: 0, fontSize: '0.75rem', color: '#94a3b8'}}>{formatNumber(stardustMinY)}</div>
                    </div>
                )}
            </div>

            <div>
                <h3 className="font-orbitron" style={{fontSize: '1.125rem', marginBottom: '0.5rem', textAlign: 'center', color: 'var(--purple-400)'}}>Nebula Gas Total</h3>
                {nebulaHistory.length < 2 ? (
                    <div style={{textAlign: 'center', padding: '1rem', color: '#94a3b8'}}>Collecte des données...</div>
                ) : (
                    <div style={{position: 'relative', height: '6rem'}}>
                        <svg viewBox={`0 0 300 100`} style={{width: '100%', height: '100%'}} preserveAspectRatio="none">
                            <defs>
                                <linearGradient id="nebulaAreaGradient" x1="0" x2="0" y1="0" y2="1">
                                    <stop offset="0%" stopColor="var(--purple-400)" stopOpacity="0.4"/>
                                    <stop offset="100%" stopColor="var(--purple-400)" stopOpacity="0"/>
                                </linearGradient>
                            </defs>
                            <path d={'M ' + nebulaPathData} fill="none" stroke="var(--purple-400)" strokeWidth="2" />
                            <path d={`M ${nebulaPathData.split(' ')[0]} L ${nebulaPathData} L 300,100 L 0,100 Z`} fill="url(#nebulaAreaGradient)" />
                        </svg>
                        <div style={{position: 'absolute', top: 0, left: 0, fontSize: '0.75rem', color: '#94a3b8'}}>{formatNumber(nebulaMaxY)}</div>
                        <div style={{position: 'absolute', bottom: 0, left: 0, fontSize: '0.75rem', color: '#94a3b8'}}>{formatNumber(nebulaMinY)}</div>
                    </div>
                )}
            </div>

            <dl style={{display: 'flex', flexDirection: 'column', gap: '0.5rem'}}>
                <StatDisplay label="Stardust/sec" value={formatNumber(stats.stardustPerSecond)} />
                <StatDisplay label="Gaz Nébuleux/sec" value={formatNumber(stats.nebulaPerSecond)} />
                <StatDisplay label="Stardust/clic" value={formatNumber(stats.stardustPerClick)} />
                <StatDisplay label="Bonus de Prestige" value={stats.prestigeBonus} />
                <StatDisplay label="Clics totaux" value={formatNumber(stats.totalClicks)} />
                <StatDisplay label="Poussière d'étoiles (cette Supernova)" value={stats.totalStardustEver} />
                <StatDisplay label="Gaz Nébuleux (cette Supernova)" value={stats.totalNebulaGasEver} />
                <StatDisplay label="Orbes collectés" value={stats.orbsClicked} />
                <StatDisplay label="Astéroïdes minés" value={stats.asteroidsMined} />
                <StatDisplay label="Supernovas" value={stats.supernovaCount} />
                <StatDisplay label="Temps de jeu" value={stats.playTime} />
            </dl>
            <div style={{paddingTop: '1rem', marginTop: '1rem', borderTop: '1px solid #334155'}}>
              <button
                onClick={onReset}
                className="button-reset"
              >
                <style>{`
                  .button-reset {
                    width: 100%;
                    background-color: #4b5563;
                    color: white;
                    font-weight: bold;
                    padding: 0.5rem 1rem;
                    border-radius: 0.5rem;
                    transition: background-color 200ms;
                  }
                  .button-reset:hover {
                    background-color: #6b7280;
                  }
                `}</style>
                Réinitialiser la Sauvegarde
              </button>
            </div>
        </div>
    );
};

const UpgradesPanel = ({ upgrades, onPurchase, currencies, onPrestige, canPrestige, prestigeCost, stardustHistory, nebulaHistory, detailedStats, onResetSave }) => {
  const [activeTab, setActiveTab] = useState(Currency.Stardust);

  const isUpgradeUnlocked = (upgrade) => {
    if (!upgrade.requirement) return true;
    const requiredUpgrade = upgrades[upgrade.requirement.upgradeId];
    return requiredUpgrade && requiredUpgrade.level >= upgrade.requirement.level;
  };
  
  const filteredUpgrades = Object.values(upgrades)
    .filter((u) => u.currency === activeTab && isUpgradeUnlocked(u));

  return (
    <div style={{backgroundColor: 'rgba(30, 41, 59, 0.5)', backdropFilter: 'blur(4px)', borderRadius: '0.5rem', border: '1px solid #334155', height: '100%', display: 'flex', flexDirection: 'column'}}>
      <div style={{display: 'flex', borderBottom: '1px solid #334155'}}>
        <TabButton tab={Currency.Stardust} activeTab={activeTab} onClick={setActiveTab} icon={<StardustIcon />} />
        <TabButton tab={Currency.NebulaGas} activeTab={activeTab} onClick={setActiveTab} icon={<NebulaGasIcon />} />
        <TabButton tab={Currency.Antimatter} activeTab={activeTab} onClick={setActiveTab} icon={<AntimatterIcon />} />
        <TabButton tab={'Stats'} activeTab={activeTab} onClick={setActiveTab} icon={<StatsIcon />} />
      </div>

      <div style={{flexGrow: 1, overflowY: 'auto'}}>
        {activeTab !== Currency.Antimatter && activeTab !== 'Stats' && (
          <div style={{padding: '1rem', display: 'flex', flexDirection: 'column', gap: '0.75rem'}}>
            {filteredUpgrades.map((upgrade) => (
              <UpgradeButton key={upgrade.id} upgrade={upgrade} onPurchase={onPurchase} canAfford={currencies[upgrade.currency] >= upgrade.cost}/>
            ))}
          </div>
        )}

        {activeTab === 'Stats' && <StatsPanel stardustHistory={stardustHistory} nebulaHistory={nebulaHistory} stats={detailedStats} onReset={onResetSave} />}

        {activeTab === Currency.Antimatter && (
            <div style={{padding: '1rem', display: 'flex', flexDirection: 'column', gap: '0.75rem'}}>
                <div style={{backgroundColor: 'rgba(15, 23, 42, 0.5)', padding: '1rem', borderRadius: '0.5rem', textAlign: 'center', border: '1px solid rgba(239, 68, 68, 0.5)'}}>
                    <h3 className="font-orbitron" style={{fontSize: '1.125rem', color: '#f87171'}}>SUPERNOVA</h3>
                    <p style={{fontSize: '0.875rem', color: '#d1d5db', marginTop: '0.5rem'}}>Réinitialisez votre progression pour gagner de l'Antimatière et débloquer de puissantes améliorations permanentes.</p>
                    <p style={{fontSize: '0.75rem', color: '#94a3b8', marginTop: '0.5rem'}}>Coût : {formatNumber(prestigeCost)} Stardust.</p>
                    <button 
                        onClick={onPrestige}
                        disabled={!canPrestige}
                        className="supernova-button"
                    >
                      <style>{`
                        .supernova-button {
                          margin-top: 1rem;
                          width: 100%;
                          background-color: #dc2626;
                          color: white;
                          font-weight: bold;
                          padding: 0.5rem 1rem;
                          border-radius: 0.5rem;
                          transition: all 200ms;
                          box-shadow: 0 10px 15px -3px rgba(239, 68, 68, 0.2), 0 4px 6px -2px rgba(239, 68, 68, 0.2);
                        }
                        .supernova-button:hover:not(:disabled) {
                          background-color: #ef4444;
                        }
                        .supernova-button:disabled {
                          background-color: #991b1b;
                          color: #94a3b8;
                          cursor: not-allowed;
                          box-shadow: none;
                        }
                      `}</style>
                        Go Supernova
                    </button>
                </div>
                {filteredUpgrades.map((upgrade) => (
                    <UpgradeButton key={upgrade.id} upgrade={upgrade} onPurchase={onPurchase} canAfford={currencies[upgrade.currency] >= upgrade.cost}/>
                ))}
            </div>
        )}
      </div>
    </div>
  );
};

// === FROM components/MainGameArea.tsx ===
const MainGameArea = ({ onClick, floatingNumbers, starPowerLevel, clickableOrbs, onOrbClick, asteroids, onAsteroidClick, collectionEffects, drones, supernovaPhase }) => {
  const safeStarPower = (typeof starPowerLevel === 'number' && isFinite(starPowerLevel)) ? starPowerLevel : 0;
  const hueShift = Math.min(safeStarPower * 0.25, 45); 
  const baseHue = 50;
  
  const fromColor = `hsl(${baseHue - hueShift}, 100%, 60%)`;
  const viaColor = `hsl(${30 - hueShift}, 95%, 55%)`;
  const toColor = `hsl(${10 - hueShift}, 90%, 50%)`;

  const starStyle = {
    background: `radial-gradient(circle at 30% 30%, ${fromColor}, ${viaColor}, ${toColor})`,
    position: 'relative',
    width: '75%',
    height: '75%',
    borderRadius: '9999px',
    boxShadow: '0 25px 50px -12px rgba(234, 179, 8, 0.3)',
    transition: 'transform 100ms ease-in-out',
  };
  
  const orbStyle = {
    position: 'absolute',
    width: '3rem',
    height: '3rem',
    borderRadius: '9999px',
    backgroundColor: 'rgba(253, 224, 71, 0.8)',
    backdropFilter: 'blur(4px)',
    border: '2px solid #fef08a',
    boxShadow: '0 10px 15px -3px rgba(250, 204, 21, 0.3), 0 4px 6px -2px rgba(250, 204, 21, 0.3)',
    animation: 'orb-pulse 2.5s ease-in-out infinite',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    color: 'black',
    fontWeight: 'bold',
    fontSize: '0.75rem',
    padding: '0.25rem',
    zIndex: 10,
  };

  const asteroidStyle = {
    position: 'absolute',
    width: '2.5rem',
    height: '2.5rem',
    color: '#94a3b8',
    filter: 'drop-shadow(0 4px 3px rgba(0,0,0,0.5))',
    zIndex: 10,
    animation: 'asteroid-float 10s linear infinite'
  };

  const collectionEffectStyle = {
    position: 'absolute',
    width: '3rem',
    height: '3rem',
    borderRadius: '9999px',
    border: '2px solid #67e8f9',
    zIndex: 11,
    pointerEvents: 'none'
  };

  const droneStyle = {
    position: 'absolute',
    width: '1.5rem',
    height: '1.5rem',
    color: '#67e8f9',
    filter: 'drop-shadow(0 0 5px #67e8f9)',
    zIndex: 12,
    transition: 'left 0.1s linear, top 0.1s linear',
    pointerEvents: 'none',
  };

  return (
    <div style={{position: 'relative', width: '100%', maxWidth: '32rem', aspectRatio: '1/1', display: 'flex', alignItems: 'center', justifyContent: 'center'}}>
      {/* Background Glow */}
      <div style={{position: 'absolute', inset: 0, backgroundColor: 'rgba(250, 204, 21, 0.2)', filter: 'blur(48px)', borderRadius: '9999px', animation: 'pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite', pointerEvents: 'none'}}></div>

      {/* Drones */}
      {drones.map(drone => (
        <div 
          key={drone.id}
          style={{
            ...droneStyle,
            left: `${drone.x}%`,
            top: `${drone.y}%`,
          }}
        >
          <DroneIcon />
        </div>
      ))}

      {/* Collection Effects */}
      {collectionEffects.map(effect => (
        <div 
          key={effect.id}
          className="animate-collect-effect"
          style={{
            ...collectionEffectStyle,
            left: `${effect.x}%`,
            top: `${effect.y}%`,
          }}
        />
      ))}

       {/* Clickable Orbs */}
       {clickableOrbs.map(orb => (
        <button
          key={orb.id}
          onClick={() => onOrbClick(orb.id)}
          className="animate-orb-pulse"
          style={{
            ...orbStyle,
            left: `${orb.x}%`,
            top: `${orb.y}%`,
            transform: 'translate(-50%, -50%)',
          }}
          aria-label={`Click to collect ${formatNumber(orb.value)} stardust`}
        >
          +{formatNumber(orb.value)}
        </button>
      ))}

      {/* Clickable Asteroids */}
      {asteroids.map(asteroid => (
        <button
          key={asteroid.id}
          onClick={() => onAsteroidClick(asteroid.id)}
          style={{
            ...asteroidStyle,
            left: `${asteroid.x}%`,
            top: `${asteroid.y}%`,
          }}
          aria-label={`Click to mine ${formatNumber(asteroid.value)} stardust`}
        >
          <AsteroidIcon />
        </button>
      ))}

      <button
        onClick={onClick}
        className="active-scale-95 star-button"
        aria-label="Click to generate stardust"
        style={starStyle}
      >
        <style>{`
            .star-button {
                opacity: 1;
                transform: scale(1);
            }
            [data-supernova-phase="collapse"] .star-button {
                animation: star-collapse-to-center 1s ease-in forwards;
            }
            [data-supernova-phase="explode"] .star-button,
            [data-supernova-phase="rebuild"] .star-button {
                opacity: 0;
            }
        `}</style>
        {/* Star Core */}
        <div style={{position: 'absolute', inset: 0, borderRadius: '9999px', backgroundColor: 'rgba(255, 255, 255, 0.5)', animation: 'pulse 3s cubic-bezier(0.4,0,0.6,1) infinite', pointerEvents: 'none'}}></div>
        {/* Star Flares */}
        <div className="animate-spin-slow" style={{position: 'absolute', inset: '0.5rem', borderRadius: '9999px', border: '2px solid rgba(253, 224, 71, 0.5)', pointerEvents: 'none'}}></div>
        <div className="animate-spin-slow-reverse" style={{position: 'absolute', inset: '1rem', borderRadius: '9999px', border: '2px solid rgba(251, 146, 60, 0.3)', pointerEvents: 'none'}}></div>
        
        {/* Floating Numbers */}
        {floatingNumbers.map(num => (
          <div
            key={num.id}
            className="font-orbitron animate-float-up"
            style={{
                position: 'absolute',
                fontSize: '1.5rem',
                fontWeight: 'bold',
                color: num.isNebula ? '#d8b4fe' : '#fef08a',
                pointerEvents: 'none',
                left: `${num.x}px`,
                top: `${num.y}px`,
                transform: 'translate(-50%, -50%)'
            }}
          >
            {num.value}
          </div>
        ))}
      </button>

      <style>{`
        .active-scale-95:active {
          transform: scale(0.95);
        }
      `}</style>
    </div>
  );
};

// === FROM components/Header.tsx ===
const CurrencyDisplay = ({ icon, amount, name, color }) => (
    <div style={{display: 'flex', alignItems: 'center', gap: '0.75rem', backgroundColor: 'rgba(30, 41, 59, 0.5)', backdropFilter: 'blur(4px)', padding: '0.75rem', borderRadius: '0.5rem', border: '1px solid #334155', color}}>
        <div style={{width: '2rem', height: '2rem'}}>{icon}</div>
        <div>
            <div className="font-orbitron" style={{fontSize: '1.25rem', lineHeight: 'none'}}>{formatNumber(amount)}</div>
            <div style={{fontSize: '0.75rem', color: '#94a3b8'}}>{name}</div>
        </div>
    </div>
);


const Header = ({ currencies }) => {
  return (
    <header style={{display: 'flex', flexDirection: 'column', justifyContent: 'space-between', alignItems: 'center', gap: '1rem'}}>
      <style>{`
        @media (min-width: 640px) {
          header {
            flex-direction: row;
            gap: 1rem;
          }
        }
      `}</style>
      <h1 className="font-orbitron" style={{fontSize: '1.875rem', fontWeight: 'bold', color: '#67e8f9', textShadow: '0 0 8px rgba(107,235,242,0.5)'}}>
         <style>{`
            @media (min-width: 1024px) {
              h1 {
                font-size: 2.25rem;
              }
            }
        `}</style>
        Cosmic Clicker
      </h1>
      <div style={{display: 'grid', gridTemplateColumns: 'repeat(3, minmax(0, 1fr))', gap: '0.5rem'}}>
        <style>{`
            @media (min-width: 768px) {
              div[style*="grid-template-columns"] {
                gap: 1rem;
              }
            }
        `}</style>
        <CurrencyDisplay
            icon={<StardustIcon />}
            amount={currencies[Currency.Stardust]}
            name="Stardust"
            color="#fde047"
        />
        <CurrencyDisplay
            icon={<NebulaGasIcon />}
            amount={currencies[Currency.NebulaGas]}
            name="Nebula Gas"
            color="#d8b4fe"
        />
        <CurrencyDisplay
            icon={<AntimatterIcon />}
            amount={currencies[Currency.Antimatter]}
            name="Antimatter"
            color="#f87171"
        />
      </div>
    </header>
  );
};

// === FROM App.tsx ===
const OfflineReportModal = ({ report, onClose }) => (
    <div className="modal-overlay">
        <style>{`
            .modal-overlay {
                position: fixed;
                inset: 0;
                background-color: rgba(0, 0, 0, 0.7);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                backdrop-filter: blur(4px);
            }
            .modal-content {
                background-color: var(--slate-800);
                border: 1px solid var(--slate-700);
                border-radius: 0.75rem;
                padding: 2rem;
                max-width: 28rem;
                width: 90%;
                text-align: center;
                animation: modal-fade-in 0.3s ease-out;
            }
            .modal-content h2 {
                font-family: var(--font-display);
                color: var(--cyan-300);
                font-size: 1.5rem;
                margin-top: 0;
            }
            .modal-content p {
                color: var(--slate-400);
                margin: 0.5rem 0 1.5rem;
            }
            .gains-grid {
                display: grid;
                grid-template-columns: 1fr;
                gap: 0.5rem;
                margin: 1.5rem 0;
                text-align: left;
            }
            @media (min-width: 640px) {
              .gains-grid {
                grid-template-columns: 1fr 1fr;
              }
            }
            .gain-item {
                display: flex;
                align-items: center;
                gap: 0.5rem;
                background-color: var(--slate-900);
                padding: 0.5rem;
                border-radius: 0.5rem;
            }
            .gain-item .icon { width: 1.5rem; height: 1.5rem; }
            .gain-item .amount { font-weight: bold; font-family: var(--font-display); }
            .gain-item .name { font-size: 0.875rem; }
            .modal-button {
                width: 100%;
                background-color: var(--cyan-400);
                color: var(--slate-900);
                font-weight: bold;
                padding: 0.75rem 1rem;
                border-radius: 0.5rem;
                transition: background-color 200ms;
            }
            .modal-button:hover {
                background-color: var(--cyan-300);
            }
        `}</style>
        <div className="modal-content">
            <h2>Bon Retour !</h2>
            <p>Pendant votre absence de {formatDuration(report.duration)}, votre empire a généré :</p>
            <div className="gains-grid">
                <div className="gain-item" style={{color: 'var(--yellow-300)'}}>
                    <div className="icon"><StardustIcon /></div>
                    <div>
                        <div className="amount">{formatNumber(report.stardust)}</div>
                        <div className="name">Stardust</div>
                    </div>
                </div>
                <div className="gain-item" style={{color: 'var(--purple-300)'}}>
                    <div className="icon"><NebulaGasIcon /></div>
                    <div>
                        <div className="amount">{formatNumber(report.nebulaGas)}</div>
                        <div className="name">Nebula Gas</div>
                    </div>
                </div>
            </div>
            <button onClick={onClose} className="modal-button">Continuer</button>
        </div>
    </div>
);


const INITIAL_UPGRADES = {
  // Stardust Upgrades
  clickPower1: { id: 'clickPower1', name: 'Cosmic Tap', description: 'Increases Stardust per click.', level: 1, baseCost: 5, cost: 5, costIncrease: 1.15, effect: level => level * 1, type: UpgradeType.Click, currency: Currency.Stardust },
  probe: { id: 'probe', name: 'Stardust Probe', description: 'Passively generates Stardust.', level: 0, baseCost: 15, cost: 15, costIncrease: 1.18, effect: level => level * 0.5, type: UpgradeType.Passive, currency: Currency.Stardust, requirement: { upgradeId: 'clickPower1', level: 5 } },
  clickPower2: { id: 'clickPower2', name: 'Star Gazer', description: 'Each level grants a bonus to Cosmic Tap.', level: 0, baseCost: 100, cost: 100, costIncrease: 1.2, effect: level => level * 5, type: UpgradeType.Click, currency: Currency.Stardust, requirement: { upgradeId: 'clickPower1', level: 10 } },
  reinforcedProbes: { id: 'reinforcedProbes', name: 'Reinforced Probes', description: 'Stardust Probes are 25% more effective.', level: 0, baseCost: 500, cost: 500, costIncrease: 2, effect: level => 1 + level * 0.25, type: UpgradeType.Utility, currency: Currency.Stardust, requirement: { upgradeId: 'probe', level: 10 } },
  asteroidMining: { id: 'asteroidMining', name: 'Asteroid Mining', description: 'Mine asteroids for a new source of Stardust.', level: 0, baseCost: 1000, cost: 1000, costIncrease: 1.2, effect: level => level * 10, type: UpgradeType.Passive, currency: Currency.Stardust, requirement: { upgradeId: 'probe', level: 25 } },
  asteroidProspecting: { id: 'asteroidProspecting', name: 'Asteroid Prospecting', description: 'Deploy probes that have a chance to find clickable asteroids.', level: 0, baseCost: 25000, cost: 25000, costIncrease: 1.3, effect: level => level * 0.05, type: UpgradeType.Utility, currency: Currency.Stardust, requirement: { upgradeId: 'asteroidMining', level: 1 } },
  cometChasers: { id: 'cometChasers', name: 'Comet Chasers', description: 'Boosts Asteroid Mining production by 50%.', level: 0, baseCost: 5000, cost: 5000, costIncrease: 2.5, effect: level => 1 + level * 0.5, type: UpgradeType.Utility, currency: Currency.Stardust, requirement: { upgradeId: 'asteroidMining', level: 5 } },
  asteroidCracker: { id: 'asteroidCracker', name: 'Asteroid Cracker', description: 'Increases the amount of Stardust gained from asteroids.', level: 0, baseCost: 250000, cost: 250000, costIncrease: 1.8, effect: level => 1 + level * 0.5, type: UpgradeType.Utility, currency: Currency.Stardust, requirement: { upgradeId: 'asteroidProspecting', level: 5 } },
  solarWinds: { id: 'solarWinds', name: 'Solar Winds', description: 'Boosts all passive Stardust generation by 10%.', level: 0, baseCost: 15000, cost: 15000, costIncrease: 3, effect: level => 1 + level * 0.1, type: UpgradeType.Utility, currency: Currency.Stardust, requirement: { upgradeId: 'asteroidMining', level: 15 } },
  collectorDrones: { id: 'collectorDrones', name: 'Collector Drones', description: 'Automatically collect asteroids. At Lvl 3, a drone is dispatched for each asteroid.', level: 0, baseCost: 75000, cost: 75000, costIncrease: 3, effect: level => level, type: UpgradeType.Utility, currency: Currency.Stardust, maxLevel: 3, requirement: { upgradeId: 'asteroidProspecting', level: 1 } },
  dysonSwarm: { id: 'dysonSwarm', name: 'Dyson Swarm', description: 'Construct a massive swarm for huge passive Stardust generation.', level: 0, baseCost: 1e7, cost: 1e7, costIncrease: 1.4, effect: level => level * 1500, type: UpgradeType.Passive, currency: Currency.Stardust, requirement: { upgradeId: 'solarWinds', level: 5 } },
  starFusion: { id: 'starFusion', name: 'Stellar Fusion', description: 'Clicking has a small chance to generate a burst of Nebula Gas.', level: 0, baseCost: 1e8, cost: 1e8, costIncrease: 2.2, effect: level => level * 0.005, type: UpgradeType.Utility, currency: Currency.Stardust, requirement: { upgradeId: 'dysonSwarm', level: 1 } },
  magneticCollectors: { id: 'magneticCollectors', name: 'Magnetic Collectors', description: 'Collector Drones travel 50% faster.', level: 0, baseCost: 5e6, cost: 5e6, costIncrease: 4, effect: level => 1 + level * 0.5, type: UpgradeType.Utility, currency: Currency.Stardust, maxLevel: 5, requirement: { upgradeId: 'collectorDrones', level: 3 } },
  photonicImpulse: { id: 'photonicImpulse', name: 'Photonic Impulse', description: 'Passively clicks the star once per second.', level: 0, baseCost: 1e9, cost: 1e9, costIncrease: 3, effect: level => level, type: UpgradeType.Passive, currency: Currency.Stardust, maxLevel: 10, requirement: { upgradeId: 'starFusion', level: 5 } },
  swarmSynergy: { id: 'swarmSynergy', name: 'Swarm Synergy', description: 'Dyson Swarm production is boosted by total clicks.', level: 0, baseCost: 5e9, cost: 5e9, costIncrease: 5, effect: (level, state) => 1 + level * Math.log10(state?.stats.totalClicks + 1) * 0.01, type: UpgradeType.Utility, currency: Currency.Stardust, requirement: { upgradeId: 'dysonSwarm', level: 10 } },
  
  // Nebula Gas Upgrades
  gasHarvester: { id: 'gasHarvester', name: 'Gas Harvester', description: 'Passively generates Nebula Gas.', level: 0, baseCost: 10000, cost: 10000, costIncrease: 1.25, effect: level => level * 0.2, type: UpgradeType.Passive, currency: Currency.Stardust },
  orbitalCollector: { id: 'orbitalCollector', name: 'Orbital Collector', description: 'Spawns clickable Stardust Fragments around the star.', level: 0, baseCost: 25, cost: 25, costIncrease: 1.5, effect: level => level * 0.05, type: UpgradeType.Utility, currency: Currency.NebulaGas, maxLevel: 100, requirement: { upgradeId: 'gasHarvester', level: 1 } },
  nebulaCondenser: { id: 'nebulaCondenser', name: 'Nebula Condenser', description: 'Boosts all passive Nebula Gas generation by 20%.', level: 0, baseCost: 50, cost: 50, costIncrease: 2, effect: level => 1 + level * 0.2, type: UpgradeType.Utility, currency: Currency.NebulaGas, requirement: { upgradeId: 'gasHarvester', level: 5 } },
  gasGiantSiphon: { id: 'gasGiantSiphon', name: 'Gas Giant Siphon', description: 'A new powerful source of passive Nebula Gas.', level: 0, baseCost: 100, cost: 100, costIncrease: 1.3, effect: level => level * 1, type: UpgradeType.Passive, currency: Currency.NebulaGas, requirement: { upgradeId: 'gasHarvester', level: 15 } },
  orbitalDrones: { id: 'orbitalDrones', name: 'Orbital Drones', description: 'Automatically collect Stardust Fragments. At Lvl 3, collection is instant.', level: 0, baseCost: 250, cost: 250, costIncrease: 3, effect: level => level, type: UpgradeType.Utility, currency: Currency.NebulaGas, maxLevel: 3, requirement: { upgradeId: 'orbitalCollector', level: 1 } },
  cosmicForge: { id: 'cosmicForge', name: 'Cosmic Forge', description: 'Boosts Stardust click power by 1% of your Nebula Gas per second.', level: 0, baseCost: 250, cost: 250, costIncrease: 5, effect: (level, state) => { if (!state) return 1; const nebulaPerSecond = (state.upgrades.gasHarvester.effect(state.upgrades.gasHarvester.level) + state.upgrades.gasGiantSiphon.effect(state.upgrades.gasGiantSiphon.level)); return 1 + (level * 0.01 * nebulaPerSecond); }, type: UpgradeType.Utility, currency: Currency.NebulaGas, requirement: { upgradeId: 'nebulaCondenser', level: 5 } },
  gravityWells: { id: 'gravityWells', name: 'Gravity Wells', description: 'Increases the value of clickable Stardust Fragments.', level: 0, baseCost: 500, cost: 500, costIncrease: 2, effect: level => 1 + level * 0.25, type: UpgradeType.Utility, currency: Currency.NebulaGas, requirement: { upgradeId: 'orbitalCollector', level: 10 } },
  antimatterCatalyst: { id: 'antimatterCatalyst', name: 'Antimatter Catalyst', description: 'Each point of Antimatter increases click power by 2%.', level: 0, baseCost: 1000, cost: 1000, costIncrease: 2.5, effect: (level, state) => { if (!state) return 1; return 1 + (level * 0.02 * state.currencies[Currency.Antimatter]); }, type: UpgradeType.Utility, currency: Currency.NebulaGas, requirement: { upgradeId: 'gravityWells', level: 5 } },
  stellarNursery: { id: 'stellarNursery', name: 'Stellar Nursery', description: 'Greatly increases passive Nebula Gas generation.', level: 0, baseCost: 500000, cost: 500000, costIncrease: 2.5, effect: level => 1 + level * 0.2, type: UpgradeType.Utility, currency: Currency.Stardust, requirement: { upgradeId: 'gasGiantSiphon', level: 5 } },
  gasSpectroscopy: { id: 'gasSpectroscopy', name: 'Gas Spectroscopy', description: 'All Stardust upgrades are 5% cheaper per level.', level: 0, baseCost: 750, cost: 750, costIncrease: 2, effect: level => 1 - level * 0.05, type: UpgradeType.Utility, currency: Currency.NebulaGas, maxLevel: 10, requirement: { upgradeId: 'cosmicForge', level: 3 } },
  plasmaConduits: { id: 'plasmaConduits', name: 'Plasma Conduits', description: 'Boosts all passive generation (Stardust & Gas) by 5% per level.', level: 0, baseCost: 1500, cost: 1500, costIncrease: 2.5, effect: level => 1 + level * 0.05, type: UpgradeType.Utility, currency: Currency.NebulaGas, requirement: { upgradeId: 'gasSpectroscopy', level: 2 } },
  exoticMatter: { id: 'exoticMatter', name: 'Exotic Matter', description: 'Boosts click power based on your total Nebula Gas.', level: 0, baseCost: 5000, cost: 5000, costIncrease: 3, effect: (level, state) => 1 + level * Math.log10(state?.totalNebulaGasEver + 1) * 0.01, type: UpgradeType.Utility, currency: Currency.NebulaGas, requirement: { upgradeId: 'plasmaConduits', level: 5 } },
  nebulaRefining: { id: 'nebulaRefining', name: 'Nebula Refining', description: 'Clicking has a very small chance to generate 1 Antimatter.', level: 0, baseCost: 25000, cost: 25000, costIncrease: 10, effect: level => level * 0.00001, type: UpgradeType.Utility, currency: Currency.NebulaGas, maxLevel: 5, requirement: { upgradeId: 'exoticMatter', level: 1 } },

  // Antimatter Upgrades
  acceleratedLearning: { id: 'acceleratedLearning', name: 'Accelerated Learning', description: 'Reduces the cost of all non-Antimatter upgrades by 2% per level.', level: 0, baseCost: 10, cost: 10, costIncrease: 4, effect: level => 1 - level * 0.02, type: UpgradeType.Prestige, currency: Currency.Antimatter, maxLevel: 25 },
  darkMatter: { id: 'darkMatter', name: 'Initial Dark Matter', description: 'Start each Supernova with a base amount of Stardust.', level: 0, baseCost: 5, cost: 5, costIncrease: 2, effect: level => level * 1000, type: UpgradeType.Prestige, currency: Currency.Antimatter },
  quantumFoam: { id: 'quantumFoam', name: 'Quantum Foam', description: 'Start each Supernova with a base amount of Nebula Gas.', level: 0, baseCost: 15, cost: 15, costIncrease: 2.5, effect: level => level * 100, type: UpgradeType.Prestige, currency: Currency.Antimatter, requirement: { upgradeId: 'darkMatter', level: 1 } },
  cosmicEssence: { id: 'cosmicEssence', name: 'Cosmic Essence', description: 'Increases passive generation of Stardust and Nebula Gas by 15% per level.', level: 0, baseCost: 25, cost: 25, costIncrease: 3, effect: level => 1 + level * 0.15, type: UpgradeType.Prestige, currency: Currency.Antimatter },
  persistentProbes: { id: 'persistentProbes', name: 'Persistent Probes', description: 'Start each Supernova with 5 free levels of Stardust Probes.', level: 0, baseCost: 30, cost: 30, costIncrease: 4, effect: level => level * 5, type: UpgradeType.Prestige, currency: Currency.Antimatter, maxLevel: 10, requirement: { upgradeId: 'darkMatter', level: 5 } },
  temporalWarp: { id: 'temporalWarp', name: 'Temporal Warp', description: 'Offline progress is calculated at 2% higher efficiency per level.', level: 0, baseCost: 50, cost: 50, costIncrease: 5, effect: level => 1 + level * 0.02, type: UpgradeType.Prestige, currency: Currency.Antimatter, maxLevel: 25, requirement: { upgradeId: 'cosmicEssence', level: 3 } },
  singularity: { id: 'singularity', name: 'Singularity', description: 'The passive bonus from Supernovas is 1% more effective per level.', level: 0, baseCost: 100, cost: 100, costIncrease: 2, effect: level => level * 0.01, type: UpgradeType.Prestige, currency: Currency.Antimatter, requirement: { upgradeId: 'temporalWarp', level: 1 } },
  unlockStardustUpgrades: { id: 'unlockStardustUpgrades', name: 'Stardust Blueprints', description: 'Keep Stardust upgrades after a Supernova.', level: 0, baseCost: 250, cost: 250, costIncrease: 10, effect: level => level, type: UpgradeType.Prestige, currency: Currency.Antimatter, maxLevel: 1, requirement: { upgradeId: 'singularity', level: 5 } },
  unlockNebulaUpgrades: { id: 'unlockNebulaUpgrades', name: 'Nebula Schematics', description: 'Keep Nebula Gas upgrades after a Supernova.', level: 0, baseCost: 500, cost: 500, costIncrease: 10, effect: level => level, type: UpgradeType.Prestige, currency: Currency.Antimatter, maxLevel: 1, requirement: { upgradeId: 'unlockStardustUpgrades', level: 1 } },
};

const SAVE_KEY = 'cosmicClickerSave';

const getInitialState = () => {
    const upgradesCopy = {};
    for (const key of Object.keys(INITIAL_UPGRADES)) {
        const upgrade = INITIAL_UPGRADES[key];
        upgradesCopy[key] = { ...upgrade, baseEffect: upgrade.effect(1, null) }; // Simplified for non-state-dependent effects
    }

    return {
        currencies: {
          [Currency.Stardust]: 0,
          [Currency.NebulaGas]: 0,
          [Currency.Antimatter]: 0,
        },
        upgrades: upgradesCopy,
        totalStardustEver: 0,
        totalNebulaGasEver: 0,
        totalAntimatterEver: 0,
        stats: {
            totalClicks: 0,
            supernovaCount: 0,
            playTime: 0,
            orbsClicked: 0,
            asteroidsMined: 0,
        },
        lastTick: Date.now(),
        antimatterRetrofitDone: false,
    };
};

const loadGameState = () => {
    try {
        const savedJson = localStorage.getItem(SAVE_KEY);
        if (!savedJson) return getInitialState();

        const savedState = JSON.parse(savedJson);
        const initialState = getInitialState();
        const currentUpgrades = initialState.upgrades;

        if (savedState.upgrades) {
            for (const id in currentUpgrades) {
                const saved = savedState.upgrades[id];
                const initial = INITIAL_UPGRADES[id];
                if (saved && initial) {
                    const savedLevel = saved.level;
                    if (typeof savedLevel === 'number' && isFinite(savedLevel) && savedLevel >= 0) {
                        currentUpgrades[id].level = savedLevel;
                        const newCost = Math.ceil(initial.baseCost * Math.pow(initial.costIncrease, savedLevel));
                        currentUpgrades[id].cost = isFinite(newCost) ? newCost : initial.cost;
                    } else {
                        console.warn(`Corrupted level for upgrade '${id}'. Resetting.`);
                        currentUpgrades[id].level = initial.level;
                        currentUpgrades[id].cost = initial.cost;
                    }
                }
            }
        }
        
        const finalState = {
            ...initialState,
            currencies: savedState.currencies ?? initialState.currencies,
            totalStardustEver: savedState.totalStardustEver ?? initialState.totalStardustEver,
            totalNebulaGasEver: savedState.totalNebulaGasEver ?? initialState.totalNebulaGasEver,
            totalAntimatterEver: savedState.totalAntimatterEver ?? initialState.totalAntimatterEver,
            stats: {
                ...initialState.stats,
                ...(savedState.stats ?? {}),
            },
            upgrades: currentUpgrades,
            lastTick: savedState.lastTick ?? Date.now(),
            antimatterRetrofitDone: savedState.antimatterRetrofitDone ?? false,
        };

        // Retroactive Antimatter calculation
        if (!finalState.antimatterRetrofitDone && finalState.stats.supernovaCount > 0) {
            const S = finalState.stats.supernovaCount;
            // Sum of (1+i) for i from 0 to S-1
            const expectedAntimatter = S + (S * (S - 1) / 2);
            if (finalState.currencies[Currency.Antimatter] < expectedAntimatter) {
                finalState.currencies[Currency.Antimatter] = expectedAntimatter;
            }
            finalState.antimatterRetrofitDone = true;
        }

        return finalState;
    } catch (error) {
        console.error("Failed to load or parse saved state, starting fresh.", error);
        localStorage.removeItem(SAVE_KEY);
        return getInitialState();
    }
};


const App = () => {
  const [gameState, setGameState] = useState(loadGameState);
  const [floatingNumbers, setFloatingNumbers] = useState([]);
  const [clickableOrbs, setClickableOrbs] = useState([]);
  const [asteroids, setAsteroids] = useState([]);
  const [drones, setDrones] = useState([]);
  const [collectionEffects, setCollectionEffects] = useState([]);
  const [stardustPerSecond, setStardustPerSecond] = useState(0);
  const [nebulaPerSecond, setNebulaPerSecond] = useState(0);
  const [supernovaPhase, setSupernovaPhase] = useState('idle'); // idle, start, collapse, explode, rebuild
  const [stardustHistory, setStardustHistory] = useState([]);
  const [nebulaHistory, setNebulaHistory] = useState([]);
  const [offlineReport, setOfflineReport] = useState(null);
  const lastHistoryUpdate = useRef(Date.now());

  const prestigeCost = useMemo(() => 1e6 * Math.pow(3.5, gameState.stats.supernovaCount), [gameState.stats.supernovaCount]);

  useEffect(() => {
    const handleOfflineGains = () => {
        const offlineTime = (Date.now() - gameState.lastTick) / 1000;
        if (offlineTime > 10) { // Only show for more than 10 seconds offline
            const { upgrades, stats } = gameState;
            const supernovaBoost = 1 + (stats.supernovaCount * (0.25 + upgrades.singularity.effect(upgrades.singularity.level)));
            const solarWindsBoost = upgrades.solarWinds.effect(upgrades.solarWinds.level);
            const cosmicEssenceBoost = upgrades.cosmicEssence.effect(upgrades.cosmicEssence.level);
            const plasmaBoost = upgrades.plasmaConduits.effect(upgrades.plasmaConduits.level);
            const probeProduction = upgrades.probe.effect(upgrades.probe.level) * upgrades.reinforcedProbes.effect(upgrades.reinforcedProbes.level);
            const asteroidProduction = upgrades.asteroidMining.effect(upgrades.asteroidMining.level) * upgrades.cometChasers.effect(upgrades.cometChasers.level);
            const dysonProduction = upgrades.dysonSwarm.effect(upgrades.dysonSwarm.level) * upgrades.swarmSynergy.effect(upgrades.swarmSynergy.level, gameState);
            const autoClickProduction = upgrades.photonicImpulse.effect(upgrades.photonicImpulse.level) * getClickValue();
            const sps = (probeProduction + asteroidProduction + dysonProduction + autoClickProduction) * supernovaBoost * solarWindsBoost * cosmicEssenceBoost * plasmaBoost;
            
            const nebulaCondenserBoost = upgrades.nebulaCondenser.effect(upgrades.nebulaCondenser.level);
            const stellarNurseryBoost = upgrades.stellarNursery.effect(upgrades.stellarNursery.level);
            const nps = (upgrades.gasHarvester.effect(upgrades.gasHarvester.level) + upgrades.gasGiantSiphon.effect(upgrades.gasGiantSiphon.level)) * nebulaCondenserBoost * stellarNurseryBoost * cosmicEssenceBoost * plasmaBoost;
            
            const temporalWarpBoost = upgrades.temporalWarp.effect(upgrades.temporalWarp.level);
            
            setOfflineReport({
                stardust: sps * offlineTime * temporalWarpBoost,
                nebulaGas: nps * offlineTime * temporalWarpBoost,
                duration: offlineTime,
            });
        }
    };
    handleOfflineGains();
  }, []);

  useEffect(() => {
    const saveInterval = setInterval(() => {
        try {
            setGameState(currentGameState => {
                const stateToSave = { ...currentGameState, lastTick: Date.now() };
                localStorage.setItem(SAVE_KEY, JSON.stringify(stateToSave));
                return currentGameState;
            });
        } catch (error) {
            console.error("Failed to save game state:", error);
        }
    }, 5000);

    const handleBeforeUnload = () => {
        setGameState(currentGameState => {
            const stateToSave = { ...currentGameState, lastTick: Date.now() };
            localStorage.setItem(SAVE_KEY, JSON.stringify(stateToSave));
            return currentGameState;
        });
    };

    window.addEventListener('beforeunload', handleBeforeUnload);

    return () => {
        clearInterval(saveInterval);
        window.removeEventListener('beforeunload', handleBeforeUnload);
    };
  }, []);


  const getClickValue = useCallback(() => {
    const { upgrades, stats, currencies, totalNebulaGasEver } = gameState;
    const supernovaBoost = 1 + (stats.supernovaCount * (0.25 + upgrades.singularity.effect(upgrades.singularity.level)));
    const forgeBoost = upgrades.cosmicForge.effect(upgrades.cosmicForge.level, gameState);
    const catalystBoost = upgrades.antimatterCatalyst.effect(upgrades.antimatterCatalyst.level, gameState);
    const exoticBoost = upgrades.exoticMatter.effect(upgrades.exoticMatter.level, gameState);
    const baseClick = upgrades.clickPower1.effect(upgrades.clickPower1.level) + upgrades.clickPower2.effect(upgrades.clickPower2.level);
    return baseClick * supernovaBoost * forgeBoost * catalystBoost * exoticBoost;
  }, [gameState]);

  const handleStarClick = useCallback((e) => {
    const clickValue = getClickValue();
    let nebulaGainedFromClick = 0;
    let antimatterGainedFromClick = 0;
    const { upgrades } = gameState;
    
    if (Math.random() < upgrades.starFusion.effect(upgrades.starFusion.level)) {
        const nebulaPerSecond = (upgrades.gasHarvester.effect(upgrades.gasHarvester.level) + upgrades.gasGiantSiphon.effect(upgrades.gasGiantSiphon.level));
        nebulaGainedFromClick = (nebulaPerSecond + 1) * 60; // 1 minute of production
    }
    if (Math.random() < upgrades.nebulaRefining.effect(upgrades.nebulaRefining.level)) {
        antimatterGainedFromClick = 1;
    }

    if (nebulaGainedFromClick > 0) {
        const rect = e.currentTarget.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const newFloatingNebula = { id: Date.now() + Math.random(), value: `+${formatNumber(nebulaGainedFromClick)} Gas!`, x, y, isNebula: true };
        setFloatingNumbers(current => [...current, newFloatingNebula]);
        setTimeout(() => setFloatingNumbers(current => current.filter(n => n.id !== newFloatingNebula.id)), 2000);
    }

    setGameState(prev => ({
        ...prev,
        currencies: { 
          ...prev.currencies, 
          [Currency.Stardust]: prev.currencies[Currency.Stardust] + clickValue,
          [Currency.NebulaGas]: prev.currencies[Currency.NebulaGas] + nebulaGainedFromClick,
          [Currency.Antimatter]: prev.currencies[Currency.Antimatter] + antimatterGainedFromClick,
        },
        totalStardustEver: prev.totalStardustEver + clickValue,
        totalNebulaGasEver: prev.totalNebulaGasEver + nebulaGainedFromClick,
        totalAntimatterEver: (prev.totalAntimatterEver || 0) + antimatterGainedFromClick,
        stats: { ...prev.stats, totalClicks: prev.stats.totalClicks + 1 },
    }));

    const rect = e.currentTarget.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const newFloatingNumber = { id: Date.now() + Math.random(), value: `+${formatNumber(clickValue)}`, x, y, };
    setFloatingNumbers(current => [...current, newFloatingNumber]);
    setTimeout(() => setFloatingNumbers(current => current.filter(n => n.id !== newFloatingNumber.id)), 2000);
  }, [getClickValue, gameState]);
  
  const handleOrbClick = useCallback((orbId) => {
    const orb = clickableOrbs.find(o => o.id === orbId);
    if (!orb) return;

    setGameState(prev => ({
      ...prev,
      currencies: { ...prev.currencies, [Currency.Stardust]: prev.currencies[Currency.Stardust] + orb.value },
      totalStardustEver: prev.totalStardustEver + orb.value,
      stats: { ...prev.stats, orbsClicked: (prev.stats.orbsClicked || 0) + 1 },
    }));
    
    setClickableOrbs(prev => prev.filter(o => o.id !== orbId));
  }, [clickableOrbs]);

  const handleAsteroidClick = useCallback((asteroidId) => {
    const asteroid = asteroids.find(a => a.id === asteroidId);
    if (!asteroid) return;

    setGameState(prev => ({
      ...prev,
      currencies: { ...prev.currencies, [Currency.Stardust]: prev.currencies[Currency.Stardust] + asteroid.value },
      totalStardustEver: prev.totalStardustEver + asteroid.value,
      stats: { ...prev.stats, asteroidsMined: (prev.stats.asteroidsMined || 0) + 1 },
    }));
    
    setAsteroids(prev => prev.filter(a => a.id !== asteroidId));
  }, [asteroids]);

  const handlePurchaseUpgrade = useCallback((upgradeId) => {
    setGameState(prev => {
      const upgrade = prev.upgrades[upgradeId];
      if (upgrade.level >= (upgrade.maxLevel ?? Infinity)) return prev;

      let cost = upgrade.cost;
      
      if (upgrade.currency !== Currency.Antimatter) {
          cost *= prev.upgrades.acceleratedLearning.effect(prev.upgrades.acceleratedLearning.level);
      }
      if (upgrade.currency === Currency.Stardust) {
          cost *= prev.upgrades.gasSpectroscopy.effect(prev.upgrades.gasSpectroscopy.level);
      }
      
      if (prev.currencies[upgrade.currency] < cost) return prev;

      const newLevel = upgrade.level + 1;
      const newCost = Math.ceil(upgrade.baseCost * Math.pow(upgrade.costIncrease, newLevel));

      return {
        ...prev,
        currencies: { ...prev.currencies, [upgrade.currency]: prev.currencies[upgrade.currency] - cost },
        upgrades: { ...prev.upgrades, [upgradeId]: { ...upgrade, level: newLevel, cost: newCost } },
      };
    });
  }, []);

  const handlePrestige = useCallback(() => {
    if (gameState.currencies[Currency.Stardust] < prestigeCost || supernovaPhase !== 'idle') return;
    
    setSupernovaPhase('start');

    setTimeout(() => setSupernovaPhase('collapse'), 1000);

    setTimeout(() => {
      setSupernovaPhase('explode');
      setGameState(prev => {
          const antimatterGained = 1 + prev.stats.supernovaCount;
          const prestigeUpgrades = { ...prev.upgrades };
          
          Object.keys(INITIAL_UPGRADES).forEach(key => {
              const initialU = INITIAL_UPGRADES[key];
              if (initialU.currency === Currency.Antimatter) return;
              if (initialU.currency === Currency.Stardust && prev.upgrades.unlockStardustUpgrades.level > 0) return;
              if (initialU.currency === Currency.NebulaGas && prev.upgrades.unlockNebulaUpgrades.level > 0) return;

              prestigeUpgrades[key] = { ...INITIAL_UPGRADES[key] };
          });

          const persistentProbesLevel = prev.upgrades.persistentProbes.effect(prev.upgrades.persistentProbes.level);
          if (persistentProbesLevel > 0) {
              const probe = prestigeUpgrades.probe;
              probe.level = persistentProbesLevel;
              probe.cost = Math.ceil(probe.baseCost * Math.pow(probe.costIncrease, probe.level));
          }
          
          const startingStardust = prev.upgrades.darkMatter.effect(prev.upgrades.darkMatter.level);
          const startingNebulaGas = prev.upgrades.quantumFoam.effect(prev.upgrades.quantumFoam.level);

          return {
              ...prev,
              currencies: {
                  [Currency.Stardust]: startingStardust,
                  [Currency.NebulaGas]: startingNebulaGas,
                  [Currency.Antimatter]: prev.currencies[Currency.Antimatter] + antimatterGained,
              },
              upgrades: prestigeUpgrades,
              totalStardustEver: startingStardust,
              totalNebulaGasEver: startingNebulaGas,
              totalAntimatterEver: (prev.totalAntimatterEver || 0) + antimatterGained,
              stats: { 
                  ...prev.stats, 
                  supernovaCount: prev.stats.supernovaCount + 1,
                  orbsClicked: 0,
                  asteroidsMined: 0,
              },
              lastTick: Date.now(),
          };
      });
      setClickableOrbs([]);
      setAsteroids([]);
      setDrones([]);
      setStardustHistory([]);
      setNebulaHistory([]);
    }, 2000);

    setTimeout(() => setSupernovaPhase('rebuild'), 3500);
    setTimeout(() => setSupernovaPhase('idle'), 4500);

  }, [gameState.currencies, prestigeCost, supernovaPhase]);

  const handleResetSave = useCallback(() => {
    if (window.confirm("Êtes-vous sûr de vouloir réinitialiser votre progression ? Cette action est irréversible.")) {
        localStorage.removeItem(SAVE_KEY);
        setGameState(getInitialState());
        setFloatingNumbers([]);
        setClickableOrbs([]);
        setAsteroids([]);
        setDrones([]);
        setStardustPerSecond(0);
        setNebulaPerSecond(0);
        setStardustHistory([]);
        setNebulaHistory([]);
        lastHistoryUpdate.current = Date.now();
    }
  }, []);
  
  const triggerCollectionEffect = (item) => {
    const newEffect = { id: Date.now() + Math.random(), x: item.x, y: item.y };
    setCollectionEffects(current => [...current, newEffect]);
    setTimeout(() => {
        setCollectionEffects(current => current.filter(e => e.id !== newEffect.id));
    }, 500); // Animation duration
  };

  const gameTick = useCallback(() => {
    const now = Date.now();
    let timeDelta = (now - gameState.lastTick) / 1000;
    
    // --- Offline Progress Calculation ---
    const temporalWarpBoost = gameState.upgrades.temporalWarp.effect(gameState.upgrades.temporalWarp.level);
    if (timeDelta > 5) { // more than 5 seconds offline
        timeDelta *= temporalWarpBoost;
    }
    timeDelta = Math.min(timeDelta, 86400); // Cap offline time to 24h to prevent exploits/overflow
    timeDelta = Math.max(0, timeDelta); // Ensure no negative time delta

    // --- Passive Generation Calculation ---
    const { upgrades, stats } = gameState;
    const supernovaBoost = 1 + (stats.supernovaCount * (0.25 + upgrades.singularity.effect(upgrades.singularity.level)));
    const solarWindsBoost = upgrades.solarWinds.effect(upgrades.solarWinds.level);
    const cosmicEssenceBoost = upgrades.cosmicEssence.effect(upgrades.cosmicEssence.level);
    const plasmaBoost = upgrades.plasmaConduits.effect(upgrades.plasmaConduits.level);
    
    const probeProduction = upgrades.probe.effect(upgrades.probe.level) * upgrades.reinforcedProbes.effect(upgrades.reinforcedProbes.level);
    const asteroidProduction = upgrades.asteroidMining.effect(upgrades.asteroidMining.level) * upgrades.cometChasers.effect(upgrades.cometChasers.level);
    const dysonProduction = upgrades.dysonSwarm.effect(upgrades.dysonSwarm.level) * upgrades.swarmSynergy.effect(upgrades.swarmSynergy.level, gameState);
    const autoClickProduction = upgrades.photonicImpulse.effect(upgrades.photonicImpulse.level) * getClickValue();
    
    const sps = (probeProduction + asteroidProduction + dysonProduction + autoClickProduction) * supernovaBoost * solarWindsBoost * cosmicEssenceBoost * plasmaBoost;
    setStardustPerSecond(sps);
    
    const nebulaCondenserBoost = upgrades.nebulaCondenser.effect(upgrades.nebulaCondenser.level);
    const stellarNurseryBoost = upgrades.stellarNursery.effect(upgrades.stellarNursery.level);
    const nps = (upgrades.gasHarvester.effect(upgrades.gasHarvester.level) + upgrades.gasGiantSiphon.effect(upgrades.gasGiantSiphon.level)) * nebulaCondenserBoost * stellarNurseryBoost * cosmicEssenceBoost * plasmaBoost;
    setNebulaPerSecond(nps);

    // --- Prepare for State Changes (Work on copies) ---
    let stardustFromCollection = 0;
    let newAsteroids = [...asteroids];
    let newOrbs = [...clickableOrbs];

    // --- Asteroid Collection by Drones ---
    const droneSpeed = 20 * upgrades.magneticCollectors.effect(upgrades.magneticCollectors.level);
    const moveDist = droneSpeed * timeDelta;
    const collectedAsteroidIds = new Set();
    
    const nextDrones = drones.map(drone => {
        const target = newAsteroids.find(a => a.id === drone.targetId);
        if (!target) return null;

        const dx = target.x - drone.x;
        const dy = target.y - drone.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist <= moveDist) {
            stardustFromCollection += target.value;
            collectedAsteroidIds.add(target.id);
            triggerCollectionEffect(target);
            return null; // Drone is consumed after collection
        } else if (dist > 0) {
            // Return a new drone object to respect immutability
            return {
                ...drone,
                x: drone.x + (dx / dist) * moveDist,
                y: drone.y + (dy / dist) * moveDist,
            };
        }
        return drone; // Return unmodified drone if it's already at the target
    }).filter(Boolean);


    if (collectedAsteroidIds.size > 0) {
        newAsteroids = newAsteroids.filter(a => !collectedAsteroidIds.has(a.id));
    }
    const numAsteroidsCollectedByDrones = collectedAsteroidIds.size;
    
    // --- Orb Collection by Drones ---
    const orbitalDroneLevel = upgrades.orbitalDrones.level;
    let numOrbsCollectedByDrones = 0;
    if (orbitalDroneLevel >= 3 && newOrbs.length > 0) {
        const valueFromOrbs = newOrbs.reduce((sum, o) => sum + o.value, 0);
        stardustFromCollection += valueFromOrbs;
        newOrbs.forEach(triggerCollectionEffect);
        numOrbsCollectedByDrones = newOrbs.length;
        newOrbs = [];
    }

    // --- Object Spawning ---
    const collector = upgrades.orbitalCollector;
    if (collector.level > 0 && newOrbs.length < 10) {
        if (Math.random() < collector.effect(collector.level) * timeDelta) {
            const angle = Math.random() * 2 * Math.PI;
            newOrbs.push({
                id: Date.now() + Math.random(),
                value: (sps + getClickValue()) * (5 + collector.level * 0.5) * upgrades.gravityWells.effect(upgrades.gravityWells.level),
                x: 50 + Math.cos(angle) * (40 + Math.random() * 5),
                y: 50 + Math.sin(angle) * (40 + Math.random() * 5),
            });
        }
    }

    const prospector = upgrades.asteroidProspecting;
    if (prospector.level > 0 && newAsteroids.length < 5) {
        if (Math.random() < prospector.effect(prospector.level) * timeDelta) {
            const angle = Math.random() * 2 * Math.PI;
            const newAsteroid = {
                id: Date.now() + Math.random(),
                value: (sps + getClickValue()) * (10 + prospector.level) * upgrades.asteroidCracker.effect(upgrades.asteroidCracker.level),
                x: 50 + Math.cos(angle) * (45 + Math.random() * 5),
                y: 50 + Math.sin(angle) * (45 + Math.random() * 5),
            };
            newAsteroids.push(newAsteroid);
            if (upgrades.collectorDrones.level >= 3 && !nextDrones.find(d => d.targetId === newAsteroid.id)) {
                nextDrones.push({ id: Date.now() + Math.random(), targetId: newAsteroid.id, x: 50, y: 50 });
            }
        }
    }
    
    // --- Commit All State Updates Atomically ---
    setAsteroids(newAsteroids);
    setClickableOrbs(newOrbs);
    setDrones(nextDrones);

    setGameState(prev => {
        const stardustFromPassive = sps * timeDelta;
        const nebulaFromPassive = nps * timeDelta;

        const newStardust = prev.currencies[Currency.Stardust] + stardustFromPassive + stardustFromCollection;
        const newNebulaGas = prev.currencies[Currency.NebulaGas] + nebulaFromPassive;
        
        if (now - lastHistoryUpdate.current >= 1000) {
            lastHistoryUpdate.current = now;
            setStardustHistory(prevHistory => {
                const newEntry = { timestamp: now, totalStardust: newStardust };
                return [...prevHistory, newEntry].slice(-60);
            });
            setNebulaHistory(prevHistory => {
                const newEntry = { timestamp: now, totalNebulaGas: newNebulaGas };
                return [...prevHistory, newEntry].slice(-60);
            });
        }
        
        return {
            ...prev,
            currencies: {
                ...prev.currencies,
                [Currency.Stardust]: newStardust,
                [Currency.NebulaGas]: newNebulaGas,
            },
            totalStardustEver: prev.totalStardustEver + stardustFromPassive + stardustFromCollection,
            totalNebulaGasEver: prev.totalNebulaGasEver + nebulaFromPassive,
            stats: { 
                ...prev.stats, 
                playTime: prev.stats.playTime + timeDelta,
                asteroidsMined: (prev.stats.asteroidsMined || 0) + numAsteroidsCollectedByDrones,
                orbsClicked: (prev.stats.orbsClicked || 0) + numOrbsCollectedByDrones,
            },
            lastTick: now,
        };
    });
}, [gameState, getClickValue, asteroids, clickableOrbs, drones]);

  useGameLoop(gameTick, 100);

  const starPowerLevel = useMemo(() => Object.values(gameState.upgrades)
    .filter((u) => u.currency === Currency.Stardust)
    .reduce((sum, u) => sum + (u.level || 0), 0), [gameState.upgrades]);

  const detailedStats = useMemo(() => {
      const playTime = gameState.stats.playTime;
      const hours = Math.floor(playTime / 3600);
      const minutes = Math.floor((playTime % 3600) / 60);
      const seconds = Math.floor(playTime % 60);
      const formattedPlayTime = `${hours}h ${minutes}m ${seconds}s`;
      const prestigeBonusRaw = 0.25 + gameState.upgrades.singularity.effect(gameState.upgrades.singularity.level);

      return {
          stardustPerSecond: stardustPerSecond,
          nebulaPerSecond: nebulaPerSecond,
          stardustPerClick: getClickValue(),
          totalClicks: gameState.stats.totalClicks,
          supernovaCount: gameState.stats.supernovaCount,
          playTime: formattedPlayTime,
          prestigeBonus: `${(gameState.stats.supernovaCount * prestigeBonusRaw * 100).toFixed(0)}%`,
          totalStardustEver: formatNumber(gameState.totalStardustEver),
          totalNebulaGasEver: formatNumber(gameState.totalNebulaGasEver),
          orbsClicked: formatNumber(gameState.stats.orbsClicked || 0),
          asteroidsMined: formatNumber(gameState.stats.asteroidsMined || 0),
      }
  }, [stardustPerSecond, nebulaPerSecond, getClickValue, gameState]);

  return (
    <div className="app-container">
      <style>{`
        .app-container {
          min-height: 100vh;
          display: flex;
          flex-direction: column;
          background: linear-gradient(to bottom, #0f172a, black);
        }
        .app-main-layout {
          flex-grow: 1;
          display: flex;
          flex-direction: column;
          gap: 1rem;
          padding: 1rem;
          overflow: hidden;
        }
        .main-game-container {
          display: flex;
          align-items: center;
          justify-content: center;
        }
        .upgrades-container, .header-wrapper {
            transition: transform 0.5s ease-in-out, opacity 0.5s ease-in-out;
        }

        [data-supernova-phase="start"] .app-container {
            animation: shake-subtle 0.5s;
        }
        [data-supernova-phase="start"] .header-wrapper {
            animation: ui-slide-out-top 0.8s ease-in forwards;
        }
        [data-supernova-phase="start"] .upgrades-container {
            animation: ui-slide-out-right 0.8s ease-in forwards;
        }
        [data-supernova-phase="rebuild"] .header-wrapper {
            animation: ui-slide-in-top 0.8s 0.2s ease-out forwards;
        }
        [data-supernova-phase="rebuild"] .upgrades-container {
            animation: ui-slide-in-right 0.8s 0.2s ease-out forwards;
        }

        .supernova-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: radial-gradient(circle, #334155 0%, #0f172a 70%);
            z-index: 9999;
            pointer-events: none;
            animation: supernova-fade-in-out 3s ease-in-out forwards;
        }
        .supernova-overlay::before {
            content: '';
            position: absolute;
            width: 1vmin;
            height: 1vmin;
            border-radius: 50%;
            background-color: white;
            box-shadow: 0 0 60px 30px white, 0 0 100px 60px var(--cyan-300);
            animation: supernova-core-collapse-explode 1.5s ease-in-out forwards;
        }
        .supernova-overlay::after {
            content: '';
            position: absolute;
            width: 100vmin;
            height: 100vmin;
            border-radius: 50%;
            border: 3px solid white;
            animation: supernova-shockwave-ring 1s 0.1s ease-out forwards;
        }

        @media (min-width: 1024px) {
          .app-container {
            height: 100vh;
            overflow: hidden;
          }
          .app-main-layout {
            display: grid;
            grid-template-columns: 2fr 1fr;
            height: 100%;
          }
          .upgrades-container {
            min-height: 0; /* Fix for scrollbar on grid item child */
          }
        }
      `}</style>
      {offlineReport && <OfflineReportModal report={offlineReport} onClose={() => setOfflineReport(null)} />}
      {supernovaPhase === 'explode' && <div className="supernova-overlay"></div>}
      <div data-supernova-phase={supernovaPhase} style={{pointerEvents: supernovaPhase !== 'idle' ? 'none' : 'auto'}}>
          <div className="header-wrapper" style={{padding: '1rem 1rem 0 1rem', flexShrink: 0}}>
            <Header currencies={gameState.currencies} />
          </div>
          <main className="app-main-layout">
            <div className="main-game-container">
                <MainGameArea 
                  onClick={handleStarClick} 
                  floatingNumbers={floatingNumbers}
                  starPowerLevel={starPowerLevel}
                  clickableOrbs={clickableOrbs}
                  onOrbClick={handleOrbClick}
                  asteroids={asteroids}
                  onAsteroidClick={handleAsteroidClick}
                  collectionEffects={collectionEffects}
                  drones={drones}
                  supernovaPhase={supernovaPhase}
                />
            </div>
            <div className="upgrades-container">
                <UpgradesPanel 
                  upgrades={gameState.upgrades} 
                  onPurchase={handlePurchaseUpgrade} 
                  currencies={gameState.currencies}
                  onPrestige={handlePrestige}
                  canPrestige={gameState.currencies[Currency.Stardust] >= prestigeCost}
                  prestigeCost={prestigeCost}
                  stardustHistory={stardustHistory}
                  nebulaHistory={nebulaHistory}
                  detailedStats={detailedStats}
                  onResetSave={handleResetSave}
                />
            </div>
          </main>
      </div>
    </div>
  );
};

// === FROM index.tsx ===
const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

const root = ReactDOM.createRoot(rootElement);
root.render(
  <StrictMode>
    <App />
  </StrictMode>
);

    </script>
  </body>
</html>